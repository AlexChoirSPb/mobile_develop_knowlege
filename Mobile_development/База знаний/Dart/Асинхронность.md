
Есть процессы. Они могут обмениваться информацией друг с другом и выполняться параллельно.  
Есть потоки, внутри одного процесса. Процессами мы управлять не можем, а вот потоками можем без проблем.  
**Асинхронность и многопоточность**. Многопоточность - это когда у нас выполнение кода поделено на потоки, которые выполняются вместе, параллельно. Асинхронноть работает в рамках одного потока, и асинхронность не про одновременное выполнение кода, она про то, что какую-то задачу можно не ждать и выполнять код дальше.  
Для асинхронного кода используется класс Future():  
  
Этот класс представляет из себя **набор действий**  
`Future.delayed(300);` <-- метод позволяет просто подождать какое-то время в мс, время задержки передается в качестве аргумента:  
  
```dart
print(1);  
print(2);  
print(3);  
var waitingFuture = Future<Object?>.delayed(Duration(seconds: 10));  
waitingFuture.then((_) => print(4)); //<-- аргумент "_" можно указывать, когда аргументы никакие не передаются  
print(5);  
print(6);  
print(7);  
```
  
В данном случае у нас в консоли будет: 1,2,3,5,6,7, а через 10 секунд после старта программы появится 4.  
  
Тут как с промисами в js, Future вернет какое-то значение, а метод then принимает в себя колбек с этим значением в качестве аргумента, колбек как-то с этим значением работает, но при этом код продолжает выполняться. Поэтому сначала выполнятся все принты, а потом уже Future.
  
Этот код будет выполняться не многопоточно, т.е. если поток будет занят, когда Future закончит свою работу, то он будет ждать, когда освободится поток  
  
Более реальные примеры:  
- Чтение файла:  
```dart
print(1);  
final result = File('path/to/file').readAsString(); //<-- метод readAsString возвращает Future  
print(2);  
result.then((value) => print(value));  
print(3); //<-- Сначала сработают принты, а потом мы увидим в консоле результат чтения файла  
```
  
  
- HTTP-Запрос:  
```dart
print(1);  
final url = Uri.parse('https://google.com'); //<-Создает урл страницы, но с типом Uri 
print(2);  
final futurePage = HttpClient().getUrl(url); //<-- Возвращает Future  
print(3);  
futurePage.then((value)=> print(value));  
print(4); 
``` 
  
Тоже самое, сначала принты, потом страница  
  
`Future.whenComplite(()=>....)` <-- тоже самое, что и then, только в этот колбек ничего не передается  
  
`Future.wait(futures)` <-- когда нужно подождать выполнение нескольких Future:  
  
```dart
final f1 = Future.delayed(Duration(seconds: 2));  
final f2 = Future.delayed(Duration(seconds: 5));  
final f3 = future.wait(f1,f2);  
f3.then((value) => .....);  
```
  
  
## Async..await
  
```dart
Future<int> sum(int a, int b) {  
	return Future.sync(()=> a+b); //<-- Future.sync делает код асинхронным  
}  
  
void main() {  
	final a = sum(1,4);  
	a.then((a){  
		print(a);  
		final b = sum(a,9);  
		b.then((b) {  
			print(b);  
			final c = sum(b,c);  
			c.then((c) => print(c));  
		});  
	});  
}  
```
  
Неудобно, правда? Чтобы  этого избежать, можно использовать async...await :
  
```dart
Final<void> example() async {  
	final a = await sum(1,4); //<-- ключевое слово await заставляет нас ждать, когда Future выполнит свою работу и вернет результат  
	print(a);  
	final b = await sum(a,9);  
	print(b);  
	final c = await sum(a,b);  
	print(c);  
}  
```
  
async..await - это сахар Future...then, так что поток свободен, он может выполнять другую работу:  
  
 ```dart
print("start");  
example();  
print("end"); //<-- Сначала start, ПОТОМ end, а потом результаты в example  
  
``` 