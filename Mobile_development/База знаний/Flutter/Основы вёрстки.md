
Во Flutter нейминг папок и файлов принят в стиле снейк кейс - **через нижний пробел строчными буквами**

## Базовые виджеты

- Виджет **Center** просто заполняет всё свободное пространство и по центру внутри себя располагает виджет, который прописывается в поле child

- Виджет **Container** - просто обёртка для других виджетов

- **Scaffold** - базовый каркас страницы
У scaffold'a есть три базовых поля - appBar(шапка), body(тело) и  floatingActionButton(кнопка)

- Виджет **Column** выстраивает виджеты, которые передаются в поле children (тип `List<Widget>`) в колонку
У него имеются следующие поля: 
mainAxisAlignment - выравнивание по главной оси
crossAxisAlignment - выравнивание по поперечной оси

- **Placeholder** - просто заполняет собой какое-то пространство

- **SizeBox** - виджет, тоже самое, что и Container, только у него можно задать только размеры и child

**Если название класса начинать с нижнего подчеркивания, то он будет доступен только внутри того файла, в котором объявлен**

- **TextStyle** - виджет для стилизации текста, передаётся в поле style виджета Text

- **Row** - как Column, только строка

- **Icon** - виджет иконки, принимает в себя `Icons.[iconName]`

- Виджет **Padding** - виджет внутренних отступов, принимает в себя поле child и padding
В padding можно передать EdgeInsets - конструктор падингов

- **Expanded** - виджет, который растягивает child'а на всю доступну длину
Если в рамках одного контейнера будет несколько таких виджетов, то они будут поровну между собой делить длину

## Лаяуты.

Ограничения для виджетов объявляются в родителях. Размеры (желаемые) задаются в самом виджете. Позиция виджета на экране устанавливается родителем

**Более детально:**
Виджет получает свои ограничения от своего родителя. "Ограничение" — это всего 4 значения: минимальная и максимальная ширина, минимальная и максимальная высота.
Затем виджет проходит по своему списку детей. Виджет сообщает своим дочерним элементам, каковы их ограничения (которые могут быть разными для каждого ребенка), а затем спрашивает каждого ребенка, какого размера он "хочет" быть.
Затем виджет размещает свои дочерние элементы (горизонтально по оси x и вертикально по оси y) один за другим.
И, наконец, виджет сообщает своему родителю о собственном размере (в пределах исходных ограничений, конечно).

**Ограничения**
В результате вышеописанного правила механизм компоновки Flutter имеет несколько важных ограничений:

- Виджет может получить свой собственный размер только в пределах ограничений, заданных ему его родителем. Это означает, что виджет обычно не может иметь любой размер, какой он хочет.
- Виджет не может знать о своем положении на экране и не определяет его, так как это решает его родитель.
- Поскольку размер и положение родителя, в свою очередь, также зависит от его собственного родителя, невозможно точно определить размер и положение любого виджета, не принимая во внимание дерево в целом.

**Tight × Loose ограничения**
Очень часто можно услышать, что некоторые ограничения являются "tight" или "loose", поэтому стоит знать, что это значит.

**tight** ограничение предполагает только точный размер. Другими словами, tight ограничение определяет свою максимальную ширину, равную его минимальной ширине, и определяет свою максимальную высоту, равную его минимальной высоте.

Если вы перейдете к box.dart в репозитории Flutter и поищете конструкторы BoxConstraints, то найдете следующее:

```dart
BoxConstraints.tight(Size size)
   : minWidth = size.width,
     maxWidth = size.width,
     minHeight = size.height,
     maxHeight = size.height;
```


**loose** ограничение, с другой стороны, устанавливает максимальную ширину/высоту, но позволяет виджету быть таким маленьким, каким он хочет. Другими словами, loose ограничение определяет минимальную ширину/высоту равной нулю:

```dart
BoxConstraints.loose(Size size)
   : minWidth = 0.0,
     maxWidth = size.width,
     minHeight = 0.0,
     maxHeight = size.height;
```
 

- Виджет **Stack()** принимает лист Виджетов в children, которые складывает буквально стопкой друг поверх друга.
У него есть потомок Positioned(), в который мы можем обернуть какой-нибудь виджет в children и настраивать его позицию в stack'е

- **CustomSingleChildLayout и CustomMultiChildLayout**
Конструктор **CustomSingleChildLayout** имеет поле child и обязательное поле delegate, который принимает в себя потомка виджета **SingleChildLayoutDelegate**, который мы должны написать сами
Этот класс должен обязательно определить метод shouldRelayout, который должен вернуть bool значение

**SingleChildLayoutDelegate** в дальнейшем будт отвечать за размеры и позиционирование, а за то, будет это происходить или нет как раз отвечает метод shouldRelayout

У класса **SingleChildLayoutDelegate** есть методы:
- getSize возвращает размеры для самого CustomSingleChildLayout 
- getConstraintsForChild возвращает размеры для ребёнка
- getPositionForChild возвращает отступы слева и сверху для позиции ребенка


**CustomMultiChildLayout** имеет children вместо child, и имеет также поле delegate, который принимает в себя потомок класса **MultiChildLayoutDelegate**
В поле children нужно не просто виджеты размещать, а только LayoutId
У него есть два параметра: id, туда передавать можно что угодно и child, куда надо прописывать виджет.
**id должны быть у всех LayoutId разные** 

Внутри **MultiChildLayoutDelegate** нужно реализовать обязательно уже два  метода:
shouldRelayout - такой же
performLayout - то место, где мы определяем LayoutId'шки
С помощью методов:
hasChild(id); <- позволяет узнать, есть ли у нас ребенок с определенным id
layoutChild(id, BoxConstraints) <- просим посчитать размер виджета LayoutId с id в рамках тех ограничений BoxConstraints, которые мы ему даём
positionChild <- говорим как будет позиционироваться виджет LayoutId

- **SingleChildScrollView** - виджет, который позволяет скролить
У виджета есть child, в который мы передаем виджет, который нужно скролить
Есть поле scrollDirection, который позволяет указать в каком направлении нужно скролить
Лучше его использовать для скрола небольшого контента

- **ListView** более универсальный, так как можно скролить несколько виджетов
У него есть несколько конструкторов - bilder, custom, separated и дефолтный
У **дефолтного конструктора** есть несколько полей:
shrinkWrap - схлопывает скролл, если мало контента
children вместо child, соответственно

**Между SingleChildScrollView  и ListView  есть разница** - ListView билдит элементы по мере видимости, а SingleChildScrollView сразу. Но при этом создаются классы виджетов, которые мы передаём в ListView

*Также, я заметил, контейнер ListView не выходит* 
*за рамки верхнего и нижнего меню телефона*

Есть конструктор по-интереснее: ListView.bilder(). Он не принимает в себя children'ов, он принимает itemBuilder, который принимает в себя замыкание (BuildContext context, int index){ return Widget widget}
И по итогу в разметке у нас не все виджеты, которые мы добавили, а только те, которые видны на экране и получается очень оптимизированный скролл
Можно прописать поле itemsCount для ограничения итогового index

Есть конструктор ListView.separated(). У него обязательно нужно передавать itemsCount, также есть такой же itemsBuilder. А также появляется новое поле separatoeBuilder, он возвращает также виджет, только после виджета из itemsBuilder, кроме последнего. По сути это разделитель для контента из itemsBuilder

## Кнопки:

- **ElevatedButton/OutLineButton/TextButton**
```dart
ElevatedButton(
  onPressed: () {}, <- обработчик нажатия, если передать null, то кнопка будет disabled
  onLongPressed: () {}, <- обработчик долгого нажатия
  child: widget,
  style: ButtonStyle(), <- стилизация кнопки
  clipBehavior - обрезает ли кнопка контент, который выходит за неё
)
```

- **IconButton**
```dart
IconButton(
  onPressed: () {},
  icon: Icon(Icons.[])
  onLongPressed - его тут нет:)
)
```

С помощью кнопки можно обновлять состояние виджета, работает для statefulWidget, для этого в обработчике нужно использовать setState(() {})

Контент кнопок в child может быть в целом любым, не только текст(кроме кнопки-иконки, там должна передаваться иконка)